<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玫瑰少年</title>
  
  <subtitle>学习和工作中的记录</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-06T10:01:18.694Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>张泉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GCD全解</title>
    <link href="http://example.com/2020/11/06/GCD%E5%85%A8%E8%A7%A3/"/>
    <id>http://example.com/2020/11/06/GCD%E5%85%A8%E8%A7%A3/</id>
    <published>2020-11-06T06:14:20.000Z</published>
    <updated>2020-11-06T10:01:18.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><ul><li><h4 id="进程（process"><a href="#进程（process" class="headerlink" title="进程（process)"></a>进程（process)</h4><p>进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程。</p><p>每个进程之间是相互独立的, 每个进程均运行在其专用且受保护的内存空间内，进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元。</p><p>进程状态：进程有三个状态，<strong>就绪</strong>，<strong>运行</strong>和<strong>阻塞</strong>。就绪状态其实就是获取了除cpu外的所有资源，只要处理器分配资源马上就可以运行。运行态就是获取了处理器分配的资源，程序开始执行，阻塞态，当程序条件不够时，需要等待条件满足时候才能执行，如等待I/O操作的时候，此刻的状态就叫阻塞态。</p></li><li><h4 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h4><p>一个进程要想执行任务,必须要有线程,至少有一条线程</p><p>一个进程的所有任务都是在线程中执行</p><p>每个应用程序想要跑起来,最少也要有一条线程存在,其实应用程序启动的时候我们的系统就会默认帮我们的应用程序开启一条线程,这条线程也叫做’主线程’,或者’UI线程’</p></li><li><h4 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h4><p>线程是进程的执行单元，进程的所有任务都在线程中执行</p><p>线程是 CPU 调用的最小单位</p><p>进程是 CPU 分配资源和调度的单位</p><p>一个程序可以对应过个进程,一个进程中可有多个线程,但至少要有一条线程</p><p>同一个进程内的线程共享进程资源</p></li><li><h4 id="线程串行、并行、同步、异步"><a href="#线程串行、并行、同步、异步" class="headerlink" title="线程串行、并行、同步、异步"></a>线程串行、并行、同步、异步</h4><p>串行：任务会根据队列的定义 FIFO 的执行，一个接一个的先进先出的进行执行，上一个没结束，后一个只能排队等待，以此类推，直到全部执行完。</p><p>并行：任务会根据队列的定义 FIFO 的执行，可以理解为同时执行，但是实际上是取出来一个就会放到别的线程，然后再取出一个放到另外一个线程，因为FIFO的动作很快，忽略不计，看起来是一起执行的，需要注意GCD会根据CPU最大线程数限制执行的线程数，如果任务过多，并不是同时开始执行。</p><p>同步：阻塞当前线程，直到执行完毕，线程才会往下运行，多个任务同步执行，顺序是固定的，总耗时是全部任务耗时的求和。</p><p>异步：线程不会阻塞，线程正常往下运行，多个任务异步执行，顺序非固定的，总耗时是耗时最长的任务的耗时时长。</p></li></ul><ul><li><h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>应用程序启动的时候，系统默认帮我们创建的线程，称之为‘主线程’或者是‘UI线程’，主线程一般用来显示或者刷新UI界面，例如异步网络请求完毕，需要刷新界面，就要回到主线程刷新</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="DispatchWorkItem"><a href="#DispatchWorkItem" class="headerlink" title="DispatchWorkItem"></a>DispatchWorkItem</h2><p>​    调度工作项，可以理解为一项任务的封装，或者说一个闭包/函数体，把你想要执行的任务写在闭包，在初始化    时传进去    </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认优先级 只带一个尾随闭包</span></span><br><span class="line"><span class="keyword">let</span> item1 = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;item1 -&gt; \(i)  thread: \(Thread.current)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// qos:任务优先级</span></span><br><span class="line"><span class="comment">// DispatchQoS.userInteractive 最高优先级，通常只做些短的快的事情，比如一些用户交互,这些事几乎是可以选择在主队列运行的</span></span><br><span class="line"><span class="comment">// DispatchQoS.userInitiated 也有高优先级，可能会花一点时间，但必须立即执行，因为是用户要求的,比如用户按了个按钮的开关</span></span><br><span class="line"><span class="comment">// DispatchQos.background 非用户强制要求的事情，可以等后台有空的情况下运行，优先级较低</span></span><br><span class="line"><span class="comment">// DispatchQos.utility 通常是你的应用程序想做的事，优先级低</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flags：特殊标记</span></span><br><span class="line"><span class="keyword">let</span> item2 = <span class="type">DispatchWorkItem</span>(qos: <span class="type">DispatchQoS</span>.userInitiated, flags: <span class="type">DispatchWorkItemFlags</span>.barrier) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;item2 -&gt; \(i)  thread: \(Thread.current)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="DispatchQueue"><a href="#DispatchQueue" class="headerlink" title="DispatchQueue"></a>DispatchQueue</h2><p>​    调度队列，在应用程序的主线程或后台线程上连续或并发地管理任务执行的对象</p><p>​    DispatchQueue有3种：</p><ul><li><p>Main queue：主(串行)(主线程)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得主队列(用来运行UI活动)</span></span><br><span class="line"><span class="keyword">let</span> mainQueue1 = <span class="type">DispatchQueue</span>.main</span><br><span class="line"><span class="comment">//主队列追加同步任务，会引起死锁 item1和item2相互等待对方先执行完</span></span><br><span class="line"><span class="comment">//mainQueue1.sync(execute: item1)</span></span><br><span class="line"><span class="comment">//mainQueue1.sync(execute: item2)</span></span><br><span class="line"><span class="comment">//主队列追加异步任务，按顺序打印</span></span><br><span class="line">mainQueue1.async(execute: item1)</span><br><span class="line">mainQueue1.async(execute: item2)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Global queue：全局(并发)(后台线程并行工作)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一队列上异步执行多个任务，而无需阻塞特定线程</span></span><br><span class="line"><span class="keyword">let</span> globalQueue1 = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="comment">//全局队列追加同步任务，按顺序打印</span></span><br><span class="line">globalQueue1.sync(execute: item1)</span><br><span class="line">globalQueue1.sync(execute: item2)</span><br><span class="line"><span class="comment">//全局队列追加异步任务，随机打印</span></span><br><span class="line">globalQueue1.async(execute: item1)</span><br><span class="line">globalQueue1.async(execute: item2)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Custom queue：自定义(并发或串行)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// label:附加到队列的字符串标签，便于调试</span></span><br><span class="line"><span class="comment">// attributes:队列的执行方式，省略按照串行执行，指定concurrent则为并列执行</span></span><br><span class="line"><span class="comment">//串行队列</span></span><br><span class="line"><span class="keyword">let</span> serialQueue1 = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.serialQueue1&quot;</span>)</span><br><span class="line"><span class="comment">//并行队列</span></span><br><span class="line"><span class="keyword">let</span> concurrentQueue1 = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.concurrentQueue1&quot;</span>, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义串行队列追加同步任务，按顺序打印</span></span><br><span class="line">serialQueue1.sync(execute: item1)</span><br><span class="line">serialQueue1.sync(execute: item2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义串行队列追加异步任务，按顺序打印</span></span><br><span class="line">serialQueue1.async(execute: item1)</span><br><span class="line">serialQueue1.async(execute: item2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义并行队列追加同步任务，按顺序打印</span></span><br><span class="line">concurrentQueue1.sync(execute: item1)</span><br><span class="line">concurrentQueue1.sync(execute: item2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义并行队列追加异步任务，随机打印</span></span><br><span class="line">concurrentQueue1.async(execute: item1)</span><br><span class="line">concurrentQueue1.async(execute: item2)</span><br><span class="line">concurrentQueue1.async(execute: item3)</span><br><span class="line">concurrentQueue1.async(execute: item4)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义串行队列追加混合任务 顺序打印</span></span><br><span class="line">serialQueue1.async(execute: item1)</span><br><span class="line">serialQueue1.sync(execute: item2)</span><br><span class="line">serialQueue1.async(execute: item3)</span><br><span class="line">serialQueue1.async(execute: item4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义并行队列追加混合任务 随机打印，同步任务执行期间不会穿插异步任务，并行队列同步任务，回到主线程执行</span></span><br><span class="line">concurrentQueue1.async(execute: item1)</span><br><span class="line">concurrentQueue1.async(execute: item2)</span><br><span class="line">concurrentQueue1.async(execute: item3)</span><br><span class="line">concurrentQueue1.sync(execute: item4)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="DispatchGroup"><a href="#DispatchGroup" class="headerlink" title="DispatchGroup"></a>DispatchGroup</h2><p>​    调度组，可以将多个任务添加到一个组，并对它们进行调度，以便在同一队列或不同队列上进行异步执行。当所有工作    项完成执行后，组执行其完成处理程序。还可以同步等待组中的所有任务完成执行。</p><p>​    DispatchGroup有三种用法：</p><ul><li><p>notify：调度组里所有任务执行完毕，会在此收到通知，不会阻塞当前线程</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group1 = <span class="type">DispatchGroup</span>()</span><br><span class="line">concurrentQueue1.async(group: group1, execute: item1)</span><br><span class="line">concurrentQueue1.async(group: group1, execute: item2)</span><br><span class="line">group1.notify(queue: concurrentQueue1) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;group1 执行完毕 thread: \(Thread.current)&quot;</span>)</span><br><span class="line">    <span class="comment">// 需要注意这里不会阻塞线程，所以不是主线程，需要UI变化操作，需要回调主线程</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;刷新UI&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>wait：    等待调度组里的所有任务执行完毕或者等待超时，会阻塞当前线程</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group2 = <span class="type">DispatchGroup</span>()</span><br><span class="line">concurrentQueue1.async(group: group2, execute: item1)</span><br><span class="line">concurrentQueue1.async(group: group2, execute: item2)</span><br><span class="line"><span class="keyword">let</span> result = group2.wait(timeout: <span class="type">DispatchTime</span>.now() + <span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> .success:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .timedOut:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;timedOut&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="DispatchGroup挂起、恢复"><a href="#DispatchGroup挂起、恢复" class="headerlink" title="DispatchGroup挂起、恢复"></a>DispatchGroup挂起、恢复</h2><p>​    前面说了DispatchGroup的notify和wait，工作场景中都是为了将耗时任务放到异步，处理完后再回到主线程处    理，这里只是简单的两个任务，就存在层级嵌套闭包回调，可以使用队列挂起和恢复解决嵌套</p><p>​    </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group3 = <span class="type">DispatchGroup</span>()</span><br><span class="line"><span class="comment">// 将并行队列挂起</span></span><br><span class="line">concurrentQueue1.suspend()</span><br><span class="line">serialQueue1.async(group: group3, execute: &#123;</span><br><span class="line">    <span class="comment">// 模拟网络加载</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;serialQueue1执行完毕&quot;</span>)</span><br><span class="line">    <span class="comment">// 将并行队列恢复</span></span><br><span class="line">    concurrentQueue1.resume()</span><br><span class="line">&#125;)</span><br><span class="line">concurrentQueue1.async(group: group3, execute: &#123;</span><br><span class="line">    <span class="comment">// 模拟网络加载</span></span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;concurrentQueue1执行完毕&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// queue:回调所在的线程，这里直接回调到了主线程</span></span><br><span class="line">group3.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;监听group3执行完毕&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会报timedOut，因为是两个耗时任务</span></span><br><span class="line"><span class="keyword">let</span> result2 = group3.wait(timeout: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> result2 &#123;</span><br><span class="line"><span class="keyword">case</span>.success:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line"><span class="keyword">case</span>.timedOut:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;timedOut&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="日常场景"><a href="#日常场景" class="headerlink" title="日常场景"></a>日常场景</h2><ul><li><p>​    APP启动后多个弹窗（隐私协议、用户守则、活动宣传、版本升级提示更新等等）</p><p>​    </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里为了示例，拿10个系统弹窗来依次执行，非一次弹出，可以设置优先级依次弹出</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.alert.pop&quot;</span>)</span><br><span class="line">queue.async &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sema = <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="keyword">let</span> alertVC = <span class="type">UIAlertController</span>()</span><br><span class="line">            alertVC.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">&quot;测试\(i)&quot;</span>, style: <span class="type">UIAlertAction</span>.<span class="type">Style</span>.cancel) &#123;<span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">                sema.signal()</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">self</span>?.present(alertVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sema.wait()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>耗时异步请求数据后回主线程刷新UI</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> groud = <span class="type">DispatchGroup</span>()</span><br><span class="line"><span class="keyword">let</span> queue1 = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.network.download1&quot;</span>,attributes: .concurrent)</span><br><span class="line"><span class="keyword">let</span> queue2 = <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.network.download2&quot;</span>,attributes: .concurrent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列挂起</span></span><br><span class="line">queue2.suspend()</span><br><span class="line">queue1.async(group: groud, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;queue1开始网络请求&quot;</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;queue1网络请求完毕&quot;</span>)</span><br><span class="line">    <span class="comment">// 恢复队列</span></span><br><span class="line">    queue2.resume()</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">queue2.async(group: groud, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;queue2开始网络请求&quot;</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;queue2网络请求完毕&quot;</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">groud.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;刷新UI&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>未完待续。。。。</p><ul><li></li><li></li><li></li><li><p>示例代码可以在这里找：<a href="https://github.com/lizzie8023/gcd.git">https://github.com/lizzie8023/gcd.git</a></p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">GCD、iOS多线程</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="工作" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用GitHub+Hexo搭建博客</title>
    <link href="http://example.com/2020/10/15/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2020/10/15/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-10-15T09:07:51.000Z</published>
    <updated>2020-10-15T09:56:51.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>日常有些需要备忘或者学习的过程，想要记录下来，自建博客是一个不错的选择，相对比自建域名搭建，GitHub+Hexo无需任何花费</p><p><strong>步骤：</strong></p><h6 id="1-首先安装Node-js"><a href="#1-首先安装Node-js" class="headerlink" title="1. 首先安装Node.js"></a>1. 首先安装Node.js</h6><p>通过homebrew，可以通过<code>brew -v</code>来看是否安装了homebrew，如果能正确显示homebrew的版本号，说明homebrew已安装，如果没有安装，可以通过以下命令安装</p><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code> </p><p>接下来安装node</p><p><code>brew link node</code></p><p><code>brew uninstall node</code></p><p><code>brew install node</code></p><p>通过node -v来检测是否安装成功，另外npm由于源服务器在国外下载node包经常超时，cnpm使用国内镜像，通过以下命令安装cnpm</p><p><code>npm config set registry https://registry.npm.taobao.org</code></p><h6 id="2-GitHub新建博客项目"><a href="#2-GitHub新建博客项目" class="headerlink" title="2.  GitHub新建博客项目"></a>2.  GitHub新建博客项目</h6><p>新建一个Git项目（首先要申请一个），然后这里有个注意点，新建博客的项目名称必须和GitHub的用户名一致，博客名称后面必须加上<code>.github.io</code>后缀，否则会无法正常显示，如果觉得需要定制化博客路径，那么可以重新建一个GitHub，专门用来博客使用，这里无需将项目clone到本地，只需要拷贝下项目地址即可。</p><h6 id="3-本地创建博客"><a href="#3-本地创建博客" class="headerlink" title="3. 本地创建博客"></a>3. 本地创建博客</h6><p>首先安装Hexo</p><p><code>npm i hexo-cli -g</code></p><p>安装完毕后输入 hexo -v校验是否成功</p><p>接下里新建博客，输入</p><p><code>hexo init &lt;博客名称&gt;</code></p><p>定位到博客目录</p><p><code>cd &lt;博客名称&gt;</code></p><p>安装所需组件</p><p><code>npm install</code></p><p>安装完毕后，可以直接输入<code>hexo g</code>生成本地静态页，然后输入<code>hexo s</code>开启本地服务器，如果因为异常关闭再次开启时会提示端口号被占用，这时候可以通过 <code>lsof -i:4000</code>查看端口占用的进程，紧接着 <code>kill -9 &lt;对应的进程PID&gt;</code></p><h6 id="4-关联到GitHub"><a href="#4-关联到GitHub" class="headerlink" title="4. 关联到GitHub"></a>4. 关联到GitHub</h6><p>目前已经成功一半了，紧接着需要将本地博客和GitHub关联上，这里先要配置本地git的config信息，如果已经配置过可以忽略</p><p><code>git config --global user.name &lt;&quot;username&quot;&gt;</code></p><p><code>git config --global user.email &lt;&quot;useremail&quot;&gt;</code></p><p>然后生成sshkey，添加到GitHub上，这里如果没有配置可以自行搜索下</p><p>接下来打开博客目录下的_config.yml配置文件</p><p>在最后一行修改配置</p><p><code>deploy:</code></p><p> <code>type: git</code></p><p> <code>repository: 此处为github的项目地址，例如：https://github.com/lizzie8023/lizzie8023.github.io.git</code></p><p> <code>branch: master</code></p><p>都配置完毕后输入</p><p><code>hexo g -d</code></p><p>生成静态页，同时推送到GitHub，这时候可以试着在游览器打开项目名称的地址，例如lizzie8023.github.io，去访问自己的博客了，这里可能受到本地缓存和git缓存影响，也有可能几分钟后才可以正常访问，如果等待一会还是无法访问，可以输入</p><p><code>hexo clean</code></p><p><code>Hexo g -d</code></p><p>清理本地静态页缓存，重新生成并提交</p><h6 id="5-配置主题"><a href="#5-配置主题" class="headerlink" title="5. 配置主题"></a>5. 配置主题</h6><p>Hexo支持的主题特别多，<a href="https://hexo.io/themes/">https://hexo.io/themes/</a> </p><p>这里用的是功能强大，可高度定制化的一个主图，next主题</p><p>还是在博客目录下，输入</p><p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><p>这里建议下载后cd到themes/next目录下，看下next的版本，最新安装next非8.0的版本有bug，本地可以显示，但是远程无法访问或者访问异常，切换到8.0即可解决</p><h6 id="6-写文章"><a href="#6-写文章" class="headerlink" title="6. 写文章"></a>6. 写文章</h6><p>可以在博客目录下的source/_posts新建一个.md文件，推荐VSCode安装一个hexo插件&gt;hexo front matter,可以一键生成头文件，然后可以输入</p><p><code>hexo g -d</code></p><p>发布上去了</p><h6 id="7-绑定域名"><a href="#7-绑定域名" class="headerlink" title="7. 绑定域名"></a>7. 绑定域名</h6><p>我到这一步尝试了下，发现阿里云上面的域名心仪的也不便宜，虽然不是自己的域名显得很没牌面，但是我觉得没太大必要搞一个，有兴趣的也可以尝试下</p><p>在github的项目地址下点击settings,滑到底部有一个Custom domain，添加上自己的域名，然后保存，这时候项目会生成一个CNAME文件，然后在里面填上自己的域名，保存即可</p>]]></content>
    
    
    <summary type="html">自建博客</summary>
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift图片压缩</title>
    <link href="http://example.com/2020/10/15/Swift%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>http://example.com/2020/10/15/Swift%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</id>
    <published>2020-10-15T08:45:12.000Z</published>
    <updated>2020-10-15T09:03:23.573Z</updated>
    
    <content type="html"><![CDATA[<p><strong>日常开发过程中，会有需求用户图片上传，如果上传的图片太大，会影响上传耗时以及考虑上传后如果没有使用类似七牛裁切、压缩相关配置，在客户端展示的时候也会影响到加载耗时，所以有必要对图片尺寸做下压缩处理，这里使用分类实现</strong></p><p><code>extension UIImage &#123;</code></p><p>``   </p><p>  <code>/// maxSize:限制的最小尺寸</code></p><p>  <code>func resetSizeOfImageData(maxSize: Int) -&gt; Data? &#123;</code></p><p>​    <code>if let imageData = self.jpegData(compressionQuality: 1.0),</code></p><p>​      <code>imageData.count &lt;= maxSize &#123;</code></p><p>​      <code>return imageData</code></p><p>​    <code>&#125;</code></p><p>``     </p><p>​    <code>func compressedDataOfImage(_ image: UIImage?) -&gt; Data? &#123;</code></p><p>​      <code>guard let image = image else &#123;</code></p><p>​        <code>return nil</code></p><p>​      <code>&#125;</code></p><p>​      <code>let imageData = image.binaryCompression(to: maxSize)</code></p><p>``       </p><p>​      <code>if imageData == nil &#123;</code></p><p>​        <code>let currentMiniIamgeDataSize = jpegData(compressionQuality: 0.01)?.count ?? 0</code></p><p>​        <code>var proportion = CGFloat(currentMiniIamgeDataSize / maxSize)</code></p><p>​        <code>proportion = proportion == 1 ? 2 : proportion</code></p><p>​        <code>let newWidth = image.size.width * scale / proportion</code></p><p>​        <code>let newHeight = image.size.height * scale / proportion</code></p><p>​        <code>let newSize = CGSize(width: newWidth, height: newHeight)</code></p><p>​        <code>UIGraphicsBeginImageContext(newSize)</code></p><p>​        <code>image.draw(in: CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height))</code></p><p>​        <code>let newImage = UIGraphicsGetImageFromCurrentImageContext()</code></p><p>​        <code>UIGraphicsEndImageContext()</code></p><p>​        <code>return compressedDataOfImage(newImage)</code></p><p>​      <code>&#125;</code></p><p>​      <code>return imageData</code></p><p>​    <code>&#125;</code></p><p>​    <code>return compressedDataOfImage(self)</code></p><p>  <code>&#125;</code></p><p>  <code>// 二分查找合适的尺寸和压缩比例</code></p><p>  <code>private func binaryCompression(to maxSize: Int) -&gt; Data? &#123;</code></p><p>​    <code>var compressionQualitys = [CGFloat](repeating: 0, count: 100)</code></p><p>​    <code>var i = compressionQualitys.count + 1</code></p><p>​    <code>// 转换0-1范围</code></p><p>​    <code>compressionQualitys = compressionQualitys.map &#123; (_) -&gt; CGFloat in</code></p><p>​      <code>let newValue = CGFloat(i) / CGFloat(compressionQualitys.count + 1)</code></p><p>​      <code>i -= 1</code></p><p>​      <code>return newValue</code></p><p>​    <code>&#125;</code></p><p>​    <code>var imageData: Data? = jpegData(compressionQuality: 1)</code></p><p>​    <code>var outPutImageData: Data?</code></p><p>​    <code>var start = 0</code></p><p>​    <code>var end = compressionQualitys.count - 1</code></p><p>​    <code>var index = 0</code></p><p>​    <code>var difference = Int.max</code></p><p>​    <code>while start &lt;= end &#123;</code></p><p>​      <code>index = start + (end - start) / 2</code></p><p>​      <code>imageData = jpegData(compressionQuality: compressionQualitys[index])</code></p><p>​      <code>let imageDataSize = imageData?.count ?? 0</code></p><p>​      <code>if imageDataSize &gt; maxSize &#123;</code></p><p>​        <code>start = index + 1</code></p><p>​      <code>&#125; else if imageDataSize &lt; maxSize &#123;</code></p><p>​        <code>if (maxSize - imageDataSize) &lt; difference &#123;</code></p><p>​          <code>difference = (maxSize - imageDataSize)</code></p><p>​          <code>outPutImageData = imageData</code></p><p>​        <code>&#125;</code></p><p>​        <code>if index &lt;= 0 &#123;</code></p><p>​          <code>break</code></p><p>​        <code>&#125;</code></p><p>​        <code>end = index - 1</code></p><p>​      <code>&#125; else &#123;</code></p><p>​        <code>break</code></p><p>​      <code>&#125;</code></p><p>​    <code>&#125;</code></p><p>​    <code>return outPutImageData</code></p><p>  <code>&#125;</code></p><p><code>&#125;</code></p>]]></content>
    
    
    <summary type="html">Swift图片压缩</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="工作" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Xcode配置</title>
    <link href="http://example.com/2020/10/15/xcode%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2020/10/15/xcode%E9%85%8D%E7%BD%AE/</id>
    <published>2020-10-15T03:46:28.000Z</published>
    <updated>2020-10-14T06:45:16.313Z</updated>
    
    <content type="html"><![CDATA[<h4 id="快捷键删除整行-or-拷贝整行"><a href="#快捷键删除整行-or-拷贝整行" class="headerlink" title="快捷键删除整行 or 拷贝整行"></a>快捷键删除整行 or 拷贝整行</h4><p>日常开发中，经常会有需要对整行的操作，比如删除无用的注释、删除修改前的代码、亦或者调整代码块间距等等</p><p>首先到Xcode的配置文件目录下</p><p><code>$ cd /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources</code></p><p>编辑配置文件</p><p><code>$ sudo vim IDETextKeyBindingSet.plist</code></p><p>按i进入编辑模式 添加下面的键值对</p><p>`<key>Custom</key><br><dict><br>  <key>Delete Current Line In One Hit</key></p><p>  <string>moveToEndOfLine:, deleteToBeginningOfLine:, deleteToEndOfParagraph:</string> </p><p>  <key>Duplicate Current Line</key></p><p>  <string>selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:</string> </p><p> </dict>`</p><p>按下esc退出编辑模式</p><p>输入:wd退出并保存</p><p>重启Xcode，在Xcode偏好设置的Key Bindings中搜索刚添加的键值对Delete Current Line In One Hit和Duplicate Current Line,设置对应的快捷键即可~</p><h4 id="代码块设置"><a href="#代码块设置" class="headerlink" title="代码块设置"></a>代码块设置</h4><p>日产开发过程中，为了便于更加专注业务逻辑部分，可以将UI相关的代码块都封装起来，例如tableView的创建代理、button的创建等等，这些是脱离在extension之外我们需要重复去构造的部分，哪怕是用extension一行代码去生成，也得根据页面单独设置样式相关，所以直接封装到代码块后，从作文题就变成填空题了，可以节省不少开发时间。</p><p>下面以tableView为例</p><p>—&gt;这里是创建部分</p><p>fileprivate lazy var &lt;#tableView#&gt;:UITableView = {</p><p>​    let view = UITableView(frame: CGRect.zero, style: UITableView.Style.grouped)</p><p>​    if #available(iOS 11.0, *) {</p><p>​      view.contentInsetAdjustmentBehavior = .never</p><p>​    } else {</p><p>​      automaticallyAdjustsScrollViewInsets = false</p><p>​    }</p><p>​    view.delegate = self</p><p>​    view.dataSource = self</p><p>​    view.estimatedRowHeight = &lt;#100#&gt;</p><p>​    view.rowHeight = UITableView.automaticDimension</p><p>​    view.separatorStyle = .none</p><p>​    view.backgroundColor = &lt;#UIColor#&gt;</p><p>​    view.register(&lt;#….#&gt;, forCellReuseIdentifier: &lt;#….#&gt;)</p><p>​    view.register(&lt;#….#&gt;, forCellReuseIdentifier: &lt;#….#&gt;)</p><p>​    view.register(&lt;#….#&gt;, forCellReuseIdentifier: &lt;#….#&gt;)</p><p>​    return view</p><p>  }()</p><p>—-&gt;这里是代理相关</p><p>extension &lt;#xxxxxxxxx#&gt;:UITableViewDelegate,UITableViewDataSource {</p><p>  func numberOfSections(in tableView: UITableView) -&gt; Int {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>  func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>  func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>}</p><p>对应配置成快捷键，日常开发需要一个list，直接xxxtabview和xxxtabdele就生成出来，然后开始根据页面定制化填写即可。</p>]]></content>
    
    
    <summary type="html">配置Xcode提高工作效率</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="工作" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习</title>
    <link href="http://example.com/2020/10/14/flutter%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2020/10/14/flutter%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-14T03:59:34.000Z</published>
    <updated>2020-10-14T06:55:25.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、变量声明"><a href="#1、变量声明" class="headerlink" title="1、变量声明"></a>1、变量声明</h3><p>已知类型var</p><p>Swift和Dart都可以自动推断类型</p><h6 id="Swift在变量名之后带上类型，已-lt-gt-分隔，Dart则在变量名之前需要写明类型"><a href="#Swift在变量名之后带上类型，已-lt-gt-分隔，Dart则在变量名之前需要写明类型" class="headerlink" title="Swift在变量名之后带上类型，已&lt;:&gt;分隔，Dart则在变量名之前需要写明类型"></a>Swift在变量名之后带上类型，已&lt;:&gt;分隔，Dart则在变量名之前需要写明类型</h6><p>Swift</p><p><code>var name:String</code></p><p><code>var name:String = &quot;Tom&quot;</code></p><p>Dart</p><p><code>String name;</code></p><p><code>String name = &#39;Tom&#39;;</code></p><p>未知类型</p><p>Swift</p><p><code>var person:Any?</code></p><p>Dart</p><p><code>Object person;</code></p><p>dynamic与var一样都是关键词,声明的变量可以赋值任意对象。</p><p>dynamic与Object相同之处在于,他们声明的变量可以在后期改变赋值类型。</p><p>dynamic与Object不同的是,dynamic声明的对象编译器会提供所有可能的组合, 而Object声明的对象只能使用Object的属性与方法, 否则编译器会报错。</p><h3 id="2、常量声明"><a href="#2、常量声明" class="headerlink" title="2、常量声明"></a>2、常量声明</h3><p>Swift使用let关键字</p><p>Dart使用final和const，const 既用于 const，也用于 final，const 变量是一个编译时常量，final变量在第一次使用时被初始化</p><p>Swift</p><p><code>let num = 10</code></p><p>Dart</p><p><code>final num = 10;</code></p><p><code>const num = 10;</code></p><h3 id="3、方法"><a href="#3、方法" class="headerlink" title="3、方法"></a>3、方法</h3><p>Swift以func关键字开始，方法名后括号内带上参数，(参数名1：参数类型1，参数名2：参数类型2 ,…),Swift是命名参数，如果不需要命名，直接将参数前面加上_即可，有返回值时在末尾接上 <code>-&gt;返回值类型</code>，没有则省略</p><p>Dart将返回值类型写在最前面，后面接方法名以及参数,Dart为未命名参数，如果需要命名，需要加上 <code>&#123;&#125;</code>将参数包起来</p><p>Swift</p><p><code>func sum(a:Int, b:Int )&#123;</code></p><p><code>&#125;</code></p><p><code>func sum(_ a:Int, _ b:Int) -&gt;Int&#123;</code></p><p><code>return ..</code></p><p><code>&#125;</code></p><p>Dart</p><p><code>void sum(int a, int b)&#123;</code></p><p><code>&#125;</code></p><p><code>int sum(&#123;int a, int b&#125;) &#123;</code></p><p><code>return ..</code></p><p><code>&#125;</code></p><h3 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h3><p>Swift</p><p><code>var block:((num:Int)-&gt;())?</code></p><p><code>block = &#123;num in</code></p><p><code>&#125;</code></p><p>Dart</p><p><code>void test(int:num)&#123;</code></p><p><code>&#125;</code></p><p><code>var block = test(int:num)</code></p><h3 id="5、数据类型"><a href="#5、数据类型" class="headerlink" title="5、数据类型"></a>5、数据类型</h3><p><strong>Array/List:</strong></p><p>Swift</p><p><code>var arrayTemp:[Int] = []</code></p><p><code>var arrayTemp2:[Int] = [1,2,3]</code></p><p><code>arrayTemp2.count // 获取元素个数</code></p><p><code>arrayTemp2[1] // 获取指定下标的元素</code></p><p>Dart</p><p><code>var arrTemp = &lt;Int&gt;[];</code></p><p><code>var arrTemp2 = [1,2,3]</code></p><p><code>arrTemp2</code></p><p><code>arrr</code></p><p><code>arrTemp2.length // 获取元素个数</code></p><p><code>arrTemp2[1] // 获取指定下标的元素</code></p><p><strong>Dictionary/Map:</strong></p><p>Swift</p><p><code>var dict:[String:Any] = [:]</code></p><p><code>var dict2 = [&quot;key&quot;:&quot;Value&quot;]</code></p><p>Dart</p><p><code>var dict = Map&lt;String,String&gt;();</code></p><p><code>var dict2 = &#123;&#39;key&#39;:&#39;value&#39;&#125;</code></p><p><strong>Bool</strong></p><p>Swift中Bool可以明确为true和false，也可以将Int转换为Bool，按照非0即真转换</p><p>Dart中Bool必须明确为true和false，如果为0，1无法正常编译</p><p><strong>Class</strong></p><p>Swift中的类初始化使用init()，使用self关键字</p><p>Dart中类初始化使用自身类名()，使用this关键字</p><p>Swift</p><p><code>class Person: NSObject &#123;</code><br>  <code>var name:String</code><br>  <code>var age:Int</code><br>  <code>init(name:String,age:Int) &#123;</code><br><code>​    self.name = name</code><br><code>​    self.age = age</code><br>  <code>&#125;</code><br><code>&#125;</code></p><p>Dart</p><p><code>class Person &#123;</code></p><p>  <code>String name;</code></p><p>  <code>int age;</code>  </p><p>  <code>Person(&#123;this.name,this.age&#125;);</code></p><p><code>&#125;</code></p><h3 id="6、字符串拼接"><a href="#6、字符串拼接" class="headerlink" title="6、字符串拼接"></a>6、字符串拼接</h3><p>Swift</p><p><code>var name = &quot;tom&quot;</code></p><p><code>print(&quot;name is \(name)&quot;)</code></p><p>Dart</p><p><code>var name = &quot;tom&quot;;</code></p><p><code>print(&#39;name is $name&#39;);</code></p>]]></content>
    
    
    <summary type="html">学习Flutter过程中的一些理解和笔记</summary>
    
    
    
    <category term="flutter" scheme="http://example.com/categories/flutter/"/>
    
    
    <category term="工作" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
</feed>
