<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玫瑰少年</title>
  
  <subtitle>学习和工作中的记录</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-15T09:56:51.466Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>张泉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用GitHub+Hexo搭建博客</title>
    <link href="http://example.com/2020/10/15/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2020/10/15/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-10-15T09:07:51.000Z</published>
    <updated>2020-10-15T09:56:51.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>日常有些需要备忘或者学习的过程，想要记录下来，自建博客是一个不错的选择，相对比自建域名搭建，GitHub+Hexo无需任何花费</p><p><strong>步骤：</strong></p><h6 id="1-首先安装Node-js"><a href="#1-首先安装Node-js" class="headerlink" title="1. 首先安装Node.js"></a>1. 首先安装Node.js</h6><p>通过homebrew，可以通过<code>brew -v</code>来看是否安装了homebrew，如果能正确显示homebrew的版本号，说明homebrew已安装，如果没有安装，可以通过以下命令安装</p><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code> </p><p>接下来安装node</p><p><code>brew link node</code></p><p><code>brew uninstall node</code></p><p><code>brew install node</code></p><p>通过node -v来检测是否安装成功，另外npm由于源服务器在国外下载node包经常超时，cnpm使用国内镜像，通过以下命令安装cnpm</p><p><code>npm config set registry https://registry.npm.taobao.org</code></p><h6 id="2-GitHub新建博客项目"><a href="#2-GitHub新建博客项目" class="headerlink" title="2.  GitHub新建博客项目"></a>2.  GitHub新建博客项目</h6><p>新建一个Git项目（首先要申请一个），然后这里有个注意点，新建博客的项目名称必须和GitHub的用户名一致，博客名称后面必须加上<code>.github.io</code>后缀，否则会无法正常显示，如果觉得需要定制化博客路径，那么可以重新建一个GitHub，专门用来博客使用，这里无需将项目clone到本地，只需要拷贝下项目地址即可。</p><h6 id="3-本地创建博客"><a href="#3-本地创建博客" class="headerlink" title="3. 本地创建博客"></a>3. 本地创建博客</h6><p>首先安装Hexo</p><p><code>npm i hexo-cli -g</code></p><p>安装完毕后输入 hexo -v校验是否成功</p><p>接下里新建博客，输入</p><p><code>hexo init &lt;博客名称&gt;</code></p><p>定位到博客目录</p><p><code>cd &lt;博客名称&gt;</code></p><p>安装所需组件</p><p><code>npm install</code></p><p>安装完毕后，可以直接输入<code>hexo g</code>生成本地静态页，然后输入<code>hexo s</code>开启本地服务器，如果因为异常关闭再次开启时会提示端口号被占用，这时候可以通过 <code>lsof -i:4000</code>查看端口占用的进程，紧接着 <code>kill -9 &lt;对应的进程PID&gt;</code></p><h6 id="4-关联到GitHub"><a href="#4-关联到GitHub" class="headerlink" title="4. 关联到GitHub"></a>4. 关联到GitHub</h6><p>目前已经成功一半了，紧接着需要将本地博客和GitHub关联上，这里先要配置本地git的config信息，如果已经配置过可以忽略</p><p><code>git config --global user.name &lt;&quot;username&quot;&gt;</code></p><p><code>git config --global user.email &lt;&quot;useremail&quot;&gt;</code></p><p>然后生成sshkey，添加到GitHub上，这里如果没有配置可以自行搜索下</p><p>接下来打开博客目录下的_config.yml配置文件</p><p>在最后一行修改配置</p><p><code>deploy:</code></p><p> <code>type: git</code></p><p> <code>repository: 此处为github的项目地址，例如：https://github.com/lizzie8023/lizzie8023.github.io.git</code></p><p> <code>branch: master</code></p><p>都配置完毕后输入</p><p><code>hexo g -d</code></p><p>生成静态页，同时推送到GitHub，这时候可以试着在游览器打开项目名称的地址，例如lizzie8023.github.io，去访问自己的博客了，这里可能受到本地缓存和git缓存影响，也有可能几分钟后才可以正常访问，如果等待一会还是无法访问，可以输入</p><p><code>hexo clean</code></p><p><code>Hexo g -d</code></p><p>清理本地静态页缓存，重新生成并提交</p><h6 id="5-配置主题"><a href="#5-配置主题" class="headerlink" title="5. 配置主题"></a>5. 配置主题</h6><p>Hexo支持的主题特别多，<a href="https://hexo.io/themes/">https://hexo.io/themes/</a> </p><p>这里用的是功能强大，可高度定制化的一个主图，next主题</p><p>还是在博客目录下，输入</p><p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><p>这里建议下载后cd到themes/next目录下，看下next的版本，最新安装next非8.0的版本有bug，本地可以显示，但是远程无法访问或者访问异常，切换到8.0即可解决</p><h6 id="6-写文章"><a href="#6-写文章" class="headerlink" title="6. 写文章"></a>6. 写文章</h6><p>可以在博客目录下的source/_posts新建一个.md文件，推荐VSCode安装一个hexo插件&gt;hexo front matter,可以一键生成头文件，然后可以输入</p><p><code>hexo g -d</code></p><p>发布上去了</p><h6 id="7-绑定域名"><a href="#7-绑定域名" class="headerlink" title="7. 绑定域名"></a>7. 绑定域名</h6><p>我到这一步尝试了下，发现阿里云上面的域名心仪的也不便宜，虽然不是自己的域名显得很没牌面，但是我觉得没太大必要搞一个，有兴趣的也可以尝试下</p><p>在github的项目地址下点击settings,滑到底部有一个Custom domain，添加上自己的域名，然后保存，这时候项目会生成一个CNAME文件，然后在里面填上自己的域名，保存即可</p>]]></content>
    
    
    <summary type="html">自建博客</summary>
    
    
    
    <category term="Hexo" scheme="http://example.com/categories/Hexo/"/>
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Swift图片压缩</title>
    <link href="http://example.com/2020/10/15/Swift%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>http://example.com/2020/10/15/Swift%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</id>
    <published>2020-10-15T08:45:12.000Z</published>
    <updated>2020-10-15T09:03:23.573Z</updated>
    
    <content type="html"><![CDATA[<p><strong>日常开发过程中，会有需求用户图片上传，如果上传的图片太大，会影响上传耗时以及考虑上传后如果没有使用类似七牛裁切、压缩相关配置，在客户端展示的时候也会影响到加载耗时，所以有必要对图片尺寸做下压缩处理，这里使用分类实现</strong></p><p><code>extension UIImage &#123;</code></p><p>``   </p><p>  <code>/// maxSize:限制的最小尺寸</code></p><p>  <code>func resetSizeOfImageData(maxSize: Int) -&gt; Data? &#123;</code></p><p>​    <code>if let imageData = self.jpegData(compressionQuality: 1.0),</code></p><p>​      <code>imageData.count &lt;= maxSize &#123;</code></p><p>​      <code>return imageData</code></p><p>​    <code>&#125;</code></p><p>``     </p><p>​    <code>func compressedDataOfImage(_ image: UIImage?) -&gt; Data? &#123;</code></p><p>​      <code>guard let image = image else &#123;</code></p><p>​        <code>return nil</code></p><p>​      <code>&#125;</code></p><p>​      <code>let imageData = image.binaryCompression(to: maxSize)</code></p><p>``       </p><p>​      <code>if imageData == nil &#123;</code></p><p>​        <code>let currentMiniIamgeDataSize = jpegData(compressionQuality: 0.01)?.count ?? 0</code></p><p>​        <code>var proportion = CGFloat(currentMiniIamgeDataSize / maxSize)</code></p><p>​        <code>proportion = proportion == 1 ? 2 : proportion</code></p><p>​        <code>let newWidth = image.size.width * scale / proportion</code></p><p>​        <code>let newHeight = image.size.height * scale / proportion</code></p><p>​        <code>let newSize = CGSize(width: newWidth, height: newHeight)</code></p><p>​        <code>UIGraphicsBeginImageContext(newSize)</code></p><p>​        <code>image.draw(in: CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height))</code></p><p>​        <code>let newImage = UIGraphicsGetImageFromCurrentImageContext()</code></p><p>​        <code>UIGraphicsEndImageContext()</code></p><p>​        <code>return compressedDataOfImage(newImage)</code></p><p>​      <code>&#125;</code></p><p>​      <code>return imageData</code></p><p>​    <code>&#125;</code></p><p>​    <code>return compressedDataOfImage(self)</code></p><p>  <code>&#125;</code></p><p>  <code>// 二分查找合适的尺寸和压缩比例</code></p><p>  <code>private func binaryCompression(to maxSize: Int) -&gt; Data? &#123;</code></p><p>​    <code>var compressionQualitys = [CGFloat](repeating: 0, count: 100)</code></p><p>​    <code>var i = compressionQualitys.count + 1</code></p><p>​    <code>// 转换0-1范围</code></p><p>​    <code>compressionQualitys = compressionQualitys.map &#123; (_) -&gt; CGFloat in</code></p><p>​      <code>let newValue = CGFloat(i) / CGFloat(compressionQualitys.count + 1)</code></p><p>​      <code>i -= 1</code></p><p>​      <code>return newValue</code></p><p>​    <code>&#125;</code></p><p>​    <code>var imageData: Data? = jpegData(compressionQuality: 1)</code></p><p>​    <code>var outPutImageData: Data?</code></p><p>​    <code>var start = 0</code></p><p>​    <code>var end = compressionQualitys.count - 1</code></p><p>​    <code>var index = 0</code></p><p>​    <code>var difference = Int.max</code></p><p>​    <code>while start &lt;= end &#123;</code></p><p>​      <code>index = start + (end - start) / 2</code></p><p>​      <code>imageData = jpegData(compressionQuality: compressionQualitys[index])</code></p><p>​      <code>let imageDataSize = imageData?.count ?? 0</code></p><p>​      <code>if imageDataSize &gt; maxSize &#123;</code></p><p>​        <code>start = index + 1</code></p><p>​      <code>&#125; else if imageDataSize &lt; maxSize &#123;</code></p><p>​        <code>if (maxSize - imageDataSize) &lt; difference &#123;</code></p><p>​          <code>difference = (maxSize - imageDataSize)</code></p><p>​          <code>outPutImageData = imageData</code></p><p>​        <code>&#125;</code></p><p>​        <code>if index &lt;= 0 &#123;</code></p><p>​          <code>break</code></p><p>​        <code>&#125;</code></p><p>​        <code>end = index - 1</code></p><p>​      <code>&#125; else &#123;</code></p><p>​        <code>break</code></p><p>​      <code>&#125;</code></p><p>​    <code>&#125;</code></p><p>​    <code>return outPutImageData</code></p><p>  <code>&#125;</code></p><p><code>&#125;</code></p>]]></content>
    
    
    <summary type="html">Swift图片压缩</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="工作" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Xcode配置</title>
    <link href="http://example.com/2020/10/15/xcode%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2020/10/15/xcode%E9%85%8D%E7%BD%AE/</id>
    <published>2020-10-15T03:46:28.000Z</published>
    <updated>2020-10-14T06:45:16.313Z</updated>
    
    <content type="html"><![CDATA[<h4 id="快捷键删除整行-or-拷贝整行"><a href="#快捷键删除整行-or-拷贝整行" class="headerlink" title="快捷键删除整行 or 拷贝整行"></a>快捷键删除整行 or 拷贝整行</h4><p>日常开发中，经常会有需要对整行的操作，比如删除无用的注释、删除修改前的代码、亦或者调整代码块间距等等</p><p>首先到Xcode的配置文件目录下</p><p><code>$ cd /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources</code></p><p>编辑配置文件</p><p><code>$ sudo vim IDETextKeyBindingSet.plist</code></p><p>按i进入编辑模式 添加下面的键值对</p><p>`<key>Custom</key><br><dict><br>  <key>Delete Current Line In One Hit</key></p><p>  <string>moveToEndOfLine:, deleteToBeginningOfLine:, deleteToEndOfParagraph:</string> </p><p>  <key>Duplicate Current Line</key></p><p>  <string>selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:</string> </p><p> </dict>`</p><p>按下esc退出编辑模式</p><p>输入:wd退出并保存</p><p>重启Xcode，在Xcode偏好设置的Key Bindings中搜索刚添加的键值对Delete Current Line In One Hit和Duplicate Current Line,设置对应的快捷键即可~</p><h4 id="代码块设置"><a href="#代码块设置" class="headerlink" title="代码块设置"></a>代码块设置</h4><p>日产开发过程中，为了便于更加专注业务逻辑部分，可以将UI相关的代码块都封装起来，例如tableView的创建代理、button的创建等等，这些是脱离在extension之外我们需要重复去构造的部分，哪怕是用extension一行代码去生成，也得根据页面单独设置样式相关，所以直接封装到代码块后，从作文题就变成填空题了，可以节省不少开发时间。</p><p>下面以tableView为例</p><p>—&gt;这里是创建部分</p><p>fileprivate lazy var &lt;#tableView#&gt;:UITableView = {</p><p>​    let view = UITableView(frame: CGRect.zero, style: UITableView.Style.grouped)</p><p>​    if #available(iOS 11.0, *) {</p><p>​      view.contentInsetAdjustmentBehavior = .never</p><p>​    } else {</p><p>​      automaticallyAdjustsScrollViewInsets = false</p><p>​    }</p><p>​    view.delegate = self</p><p>​    view.dataSource = self</p><p>​    view.estimatedRowHeight = &lt;#100#&gt;</p><p>​    view.rowHeight = UITableView.automaticDimension</p><p>​    view.separatorStyle = .none</p><p>​    view.backgroundColor = &lt;#UIColor#&gt;</p><p>​    view.register(&lt;#….#&gt;, forCellReuseIdentifier: &lt;#….#&gt;)</p><p>​    view.register(&lt;#….#&gt;, forCellReuseIdentifier: &lt;#….#&gt;)</p><p>​    view.register(&lt;#….#&gt;, forCellReuseIdentifier: &lt;#….#&gt;)</p><p>​    return view</p><p>  }()</p><p>—-&gt;这里是代理相关</p><p>extension &lt;#xxxxxxxxx#&gt;:UITableViewDelegate,UITableViewDataSource {</p><p>  func numberOfSections(in tableView: UITableView) -&gt; Int {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>  func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>  func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>  func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>  func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {</p><p>​    &lt;#code#&gt;</p><p>  }</p><p>}</p><p>对应配置成快捷键，日常开发需要一个list，直接xxxtabview和xxxtabdele就生成出来，然后开始根据页面定制化填写即可。</p>]]></content>
    
    
    <summary type="html">配置Xcode提高工作效率</summary>
    
    
    
    <category term="iOS" scheme="http://example.com/categories/iOS/"/>
    
    
    <category term="工作" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习</title>
    <link href="http://example.com/2020/10/14/flutter%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2020/10/14/flutter%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-14T03:59:34.000Z</published>
    <updated>2020-10-14T06:55:25.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、变量声明"><a href="#1、变量声明" class="headerlink" title="1、变量声明"></a>1、变量声明</h3><p>已知类型var</p><p>Swift和Dart都可以自动推断类型</p><h6 id="Swift在变量名之后带上类型，已-lt-gt-分隔，Dart则在变量名之前需要写明类型"><a href="#Swift在变量名之后带上类型，已-lt-gt-分隔，Dart则在变量名之前需要写明类型" class="headerlink" title="Swift在变量名之后带上类型，已&lt;:&gt;分隔，Dart则在变量名之前需要写明类型"></a>Swift在变量名之后带上类型，已&lt;:&gt;分隔，Dart则在变量名之前需要写明类型</h6><p>Swift</p><p><code>var name:String</code></p><p><code>var name:String = &quot;Tom&quot;</code></p><p>Dart</p><p><code>String name;</code></p><p><code>String name = &#39;Tom&#39;;</code></p><p>未知类型</p><p>Swift</p><p><code>var person:Any?</code></p><p>Dart</p><p><code>Object person;</code></p><p>dynamic与var一样都是关键词,声明的变量可以赋值任意对象。</p><p>dynamic与Object相同之处在于,他们声明的变量可以在后期改变赋值类型。</p><p>dynamic与Object不同的是,dynamic声明的对象编译器会提供所有可能的组合, 而Object声明的对象只能使用Object的属性与方法, 否则编译器会报错。</p><h3 id="2、常量声明"><a href="#2、常量声明" class="headerlink" title="2、常量声明"></a>2、常量声明</h3><p>Swift使用let关键字</p><p>Dart使用final和const，const 既用于 const，也用于 final，const 变量是一个编译时常量，final变量在第一次使用时被初始化</p><p>Swift</p><p><code>let num = 10</code></p><p>Dart</p><p><code>final num = 10;</code></p><p><code>const num = 10;</code></p><h3 id="3、方法"><a href="#3、方法" class="headerlink" title="3、方法"></a>3、方法</h3><p>Swift以func关键字开始，方法名后括号内带上参数，(参数名1：参数类型1，参数名2：参数类型2 ,…),Swift是命名参数，如果不需要命名，直接将参数前面加上_即可，有返回值时在末尾接上 <code>-&gt;返回值类型</code>，没有则省略</p><p>Dart将返回值类型写在最前面，后面接方法名以及参数,Dart为未命名参数，如果需要命名，需要加上 <code>&#123;&#125;</code>将参数包起来</p><p>Swift</p><p><code>func sum(a:Int, b:Int )&#123;</code></p><p><code>&#125;</code></p><p><code>func sum(_ a:Int, _ b:Int) -&gt;Int&#123;</code></p><p><code>return ..</code></p><p><code>&#125;</code></p><p>Dart</p><p><code>void sum(int a, int b)&#123;</code></p><p><code>&#125;</code></p><p><code>int sum(&#123;int a, int b&#125;) &#123;</code></p><p><code>return ..</code></p><p><code>&#125;</code></p><h3 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h3><p>Swift</p><p><code>var block:((num:Int)-&gt;())?</code></p><p><code>block = &#123;num in</code></p><p><code>&#125;</code></p><p>Dart</p><p><code>void test(int:num)&#123;</code></p><p><code>&#125;</code></p><p><code>var block = test(int:num)</code></p><h3 id="5、数据类型"><a href="#5、数据类型" class="headerlink" title="5、数据类型"></a>5、数据类型</h3><p><strong>Array/List:</strong></p><p>Swift</p><p><code>var arrayTemp:[Int] = []</code></p><p><code>var arrayTemp2:[Int] = [1,2,3]</code></p><p><code>arrayTemp2.count // 获取元素个数</code></p><p><code>arrayTemp2[1] // 获取指定下标的元素</code></p><p>Dart</p><p><code>var arrTemp = &lt;Int&gt;[];</code></p><p><code>var arrTemp2 = [1,2,3]</code></p><p><code>arrTemp2</code></p><p><code>arrr</code></p><p><code>arrTemp2.length // 获取元素个数</code></p><p><code>arrTemp2[1] // 获取指定下标的元素</code></p><p><strong>Dictionary/Map:</strong></p><p>Swift</p><p><code>var dict:[String:Any] = [:]</code></p><p><code>var dict2 = [&quot;key&quot;:&quot;Value&quot;]</code></p><p>Dart</p><p><code>var dict = Map&lt;String,String&gt;();</code></p><p><code>var dict2 = &#123;&#39;key&#39;:&#39;value&#39;&#125;</code></p><p><strong>Bool</strong></p><p>Swift中Bool可以明确为true和false，也可以将Int转换为Bool，按照非0即真转换</p><p>Dart中Bool必须明确为true和false，如果为0，1无法正常编译</p><p><strong>Class</strong></p><p>Swift中的类初始化使用init()，使用self关键字</p><p>Dart中类初始化使用自身类名()，使用this关键字</p><p>Swift</p><p><code>class Person: NSObject &#123;</code><br>  <code>var name:String</code><br>  <code>var age:Int</code><br>  <code>init(name:String,age:Int) &#123;</code><br><code>​    self.name = name</code><br><code>​    self.age = age</code><br>  <code>&#125;</code><br><code>&#125;</code></p><p>Dart</p><p><code>class Person &#123;</code></p><p>  <code>String name;</code></p><p>  <code>int age;</code>  </p><p>  <code>Person(&#123;this.name,this.age&#125;);</code></p><p><code>&#125;</code></p><h3 id="6、字符串拼接"><a href="#6、字符串拼接" class="headerlink" title="6、字符串拼接"></a>6、字符串拼接</h3><p>Swift</p><p><code>var name = &quot;tom&quot;</code></p><p><code>print(&quot;name is \(name)&quot;)</code></p><p>Dart</p><p><code>var name = &quot;tom&quot;;</code></p><p><code>print(&#39;name is $name&#39;);</code></p>]]></content>
    
    
    <summary type="html">学习Flutter过程中的一些理解和笔记</summary>
    
    
    
    <category term="flutter" scheme="http://example.com/categories/flutter/"/>
    
    
    <category term="工作" scheme="http://example.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
</feed>
